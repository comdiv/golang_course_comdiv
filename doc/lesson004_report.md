# Занятие 004 2021-05-18

1. Выполнение занятий по [Stepic 2.1](https://stepik.org/lesson/228838/step/1?unit=201372)
2. Определение того в какой памяти выделено место под переменную

## Тайминг

1. `(00:35)(00:35)` Выполнил раздел 2.1
2. `(00:25)(01:00)` Выполнил раздел 2.2
3. `(01:05)(02:05)` Разбирался со стеками и кучами

## Замечания

1. (+) Я так понял что компилятор сам должен строить хвостовую рекурсию, [например тут](../cmd/lesson_004/lesson_004_2_1__9.go)
2. (+) Мне в принципе нравятся множественные возвращаемые значения, а также возможность делать их именованными,
   [например тут](../cmd/lesson_004/lesson_004_2_1__10.go)
   > после беседы понял, что фича не до конца защищена и по сути лишняя
3. (-) В степике ну ОЧЕНЬ примитивно даны функции - нет ресиверов, нет именнованных возвратов,
   нет функций как типов, нет анонимных функций, нет возврата функций
4. (+) Есть вариант импорта пакета без префикса, иногда это может быть удобно, по аналогии с C#, Java 
   > после беседы пересмотрел - так то это антипаттерн все таки
5. (+) Импорт с альясом тоже есть
6. (-) Все же неявное управление видимостью через регистр первой буквы - так себе. Если надо
   поменять видимость еще и нужно рефакторинг с переименованием проводить
7. (-) В степике про модули прописано не очень внятно про структуру - типа
   ее надо придерживаться и в модулях. Но как раз сами гугловские модули не делают специальной
   структуры
8. (-) Почему-то не работает go mod why - не выводит ничего
9. (?) vendor предполагается тоже кидать в GIT или он для локальных нужд? 
   > да его сохраняют в git обычно чтобы типа все было по рукой и не зависело ни от чего
10. (+) функции малой комплексности автоматически инлайнятся если только не
    пометить их прагмой `//go:noinline` 
    > в норме никто никакими такими прагмами ничего не помечает
11. (+) есть достаточно полезный отчет о работе планировщике памяти компилятора `go build -gcflags "-m=2"`
12. (?) это специфика gcflags или вообще GO тулкита, что параметр например `-m=2`, можно записать как `-m -m`?\
    > оказывается это часто в POSIX, но по мне так это странность конкретная

## Ответ по поводу кучи и стека в GO

Вычитал следующие статьи:

1. https://medium.com/eureka-engineering/understanding-allocations-in-go-stack-heap-memory-9a2631b5035d
2. https://habr.com/ru/company/ruvds/blog/442648/
3. https://habr.com/ru/post/497994/
4. https://golang.org/cmd/compile/

Посмотрел руками пример кода со слайсом через `go build -gcflags "-m=2" cmd/lesson_004/lesson_004_heap_and_stack.go`

Из этого сделал такие выводы

1. Я как программист вообще не должен особо беспокоиться о том, где и что размещается,

   1.1  стратегия выделения памяти сложная

   1.2 у меня все равно не будет в распоряжении арифметики указателей

   1.3 зависит от версии компилятора

2. В общем случае все локальные переменные до 32kb будут полностью располгаться в стеке

3. В любом случае если компилятор не инлайнит функцию и она при этом возвращает ссылку - она будет "спасена" в кучу

4. В любом случае "большую" для данной платформы и версии компилятора переменную (в основном >32kb) компилятор
   разместит в куче

5. Если стековая память уже вся заполнена уже в рантайме (нет свободных страниц) - то тоже будет размещение в куче

6. Короче форсировать использование кучи можно через возврат ссылки и использование `//go:noinline` и
   то это только для тех значений, которые возвращаются, просто так разместить ничего в куче нельзя кроме совсем огромных
   штук типа `make([]byte, 10<<30)`

7. Форсировать использование стека нельзя - то есть он и будет использоваться в большинстве случаев, но это не нам решать

8. Надо понять, что в плане памяти GO - это не C, хотя синтаксис похож `*p`,  `&p` - нет прямого аналога
   `int *p = malloc(sizeOf(int))` и `free(p)`!

И собственно ответы на вопросы в задании:

1. `Можем ли мы уверенно сказать что слайс использованный внутри функции и не учавствуюший в возвращаемом значении был выделен на стеке` -
   уверенно - ничего нельзя сказать, во-первых что мы имеем в виду под слайсом (саму структуру или хранилище на которое он внутри ссылается и
   если там будет массив превышающий 32kb то он так и так выйдет в кучу), во-вторых как следует из статьи - при недостатке места в стеке
   для объектов определенного типа - также выделение может быть в куче

2. `Есть ли способ узнать где была выделена переменная` - в целом да - статически через `go build -gcflags "-m"`, там мы увидим
   точки где компилятор точно планирует использовать кучу "спасать в кучу", ну и частично по результатам трассирования уже с рантайма
- но там мы скорее уже будем статистически понимать, что часть значений пошла в кучу. 
