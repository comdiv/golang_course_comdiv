# Занятие 002 2021-05-12

## 002.01 Выполнение 1.4 - 1.11

Плюс контроль времени (итого `04:30` с некоторым погружением )

1. `(+00:03)(00:03)` Читал до https://stepik.org/lesson/230465/step/5?unit=202984
2. `(+00:54)(00:57)` Завис на теме строк, что это хоть и UTF, но набор байтов, а не символов
3. `(+00:15)(01:13)` Дочитал до https://stepik.org/lesson/228261/step/8?unit=200794 и решил разобраться
   со [`fmt.Scan(&a, &b, ...)`](../cmd/lesson_002_scan_multiple.go)
4. `(+00.22)(01:35)` Вернулся и прозависал с некорректной частью курса, что дескать тип выражения определяется первым
   операндом, [опровержение](../internal/experiments/lesson2_go_operandorder_test.go)\
5. `(+00:35)(02:10)` Доделывал все задания по 1.5, в последнем примере постарался покошернее с константами и контролем
   ввода
6. `(+02:18)(04:30)` Собственно проходил и делал все остальные задания

### Что надо явно иметь в виду

1. (???) Тип смешанного типа выражений определяется по `типу первого операнда`
   похоже что [ошибка в документации](https://stepik.org/lesson/228261/step/6?unit=200794)

> Арифметические операторы применяются к числовым значениям и дают результат того же типа, что и первый операнд

Но это не так, по факту как и во всех нормальных языках идет приведение к более полному типу,
опровергается [тестом](../internal/experiments/lesson2_go_operandorder_test.go),
оставил [камент в курсе](https://stepik.org/lesson/228261/step/6?discussion=3798398&unit=200794)

однако потом опять какой-то геморрой:

```
  for c:=x;c<y;years,c =years+1, int(float32(c) * (1.0 + float32(p) / 100.0)) {
    }
```

пришлось так делать, инече не хотел считать проценты и потом до целого округлять

2. (-) В go ***нет*** `префиксного инкремента ++x`
3. (+) Множественный скан косоли работает и через `arg1 ENTER arg2 ENTER ...`, так и через `arg1 arg2 ... ENTER`
4. (-) `fmt.Print` по разному ведет себя с пробелами в зависимоти от того есть ли
5. (?) В списке констант если не указать ни типа ни значения - возьмется предыдущее, какое-то косвенное присвоение,
   зависящее от порядка строк, не очень понятно (???)
6. (+?) `iota` - понятно что это просто аналог `ordinal` в `enum` у того же Kotlin, но тем не менее странноватый
   оператор, необычный
7. (+) `if` может содержать пред-инструкцию
8. (-?) не очень понятно зачем нужен `fallthrough`
9. (+) есть `switch` со свободными условиями
10. (+?) с одной стороны хорошо, что `default` в `switch` не обязатепен, но так то это точка проникновения сложных
    ошибок
11. (+) все же классический for в котором сразу все можно делать в заголовке это хорошо

### В Go строки - это просто байты, хотя по умолчанию UTF-8

Подзавис на 45 минут с тем что строки это не символы, а байты пока разбирался с этим делом подосвоил создание и запуск
тестов. [Вот первые тесты про utf-8 lesson2_utf8_string_index_test.go](../internal/experiments/lesson2_utf8_string_index_test.go)
, запуск тестов [Makefile](../Makefile) `make test_experiments` или если все то `make test`

## 002.02 Исполнить `hello, go!` без использования IDE

Для облегчения сдачи и контроля выполнения исполнил в виде [Bash скрипта](../scripts/lesson_002_noid.sh)

Внутри происходит инициализация пустой директории, создание файла .go и его выполнение с контролем корректности итогов
выполнения.

Файлы GO гарантировано порождаются во временной директории `../tmp/lesson_002_noid` не зависимо от точки файловой системы
откуда запущен скриптю

Для запуска

1. Если в системе настроен GOPATH, то просто `scripts/lesson_002_noid.sh`
2. Если нет, то соответственно `GOPATH=<путь до go/bin> scripts/lesson_002_noid.sh`

В результате должно быть напечатано следующее:

```
Out from go run
Hello, Go!
Using just created lesson_002_noid(.exe)
Result is: Hello, Go!
All is Ok!
```