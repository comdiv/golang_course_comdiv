# Занятие 004 2021-05-21

1. [Stepic: 2.4 Структуры](https://classroom.google.com/u/0/c/MzM5NDA2NTc2ODk5/a/MzQxNDE0MTE1MDQ1/details)

Вот со структурами все более менее понятно.

А вот с интерфейсами полная дичь.

Эта дичь сведена в [этом примере](../internal/experiments/interface_import_test.go)

Кратко можно сказать что:

1. Нет синтаксиса который бы явно указывал что структура должна имплементировать интерфейс, но при этом если ее кто-то
   через интерфейс использует - тут же начинает требовать реализации всех методов.
2. Ну допустим это ладно - типа это трейт, все такое - структуры сами по себе, интерфейсы сами по себе типа конвенция
3. Но ведь при этом можно интерфейс указать ВНУТРИ структуры типа унаследоваться, не реализовать НИ одного метода и при
   этом компилятор уже ругаться не будет - даст спокойно скомпилироваться и уже в рантайме начнет валить абслоютно
   невнятные `"runtime error: invalid memory address or nil pointer dereference"`, причем только для нереализвоанных
   методов.
4. При этом дефолтных реализаций у интерфейса реализовать нельзя

Вот и получается странная вещь

1. Компилятор одновременно и проверяет на наличие реализации интерфейса и одновременно НЕ проверяет если типа его
   наследовать
2. Получается что если я явно указал интерфейс - то все, можно уже и не имплементить!, а вот если я как раз ничего не
   знал про него и просто методы писал - то надо все сделать, чтобы в него уложиться
3. Единственный хак какой придумал. Прямо после определения структуры написать типа 
```golang
type MyStruct struct {
}
func _MyStructImplements() {
   var s = new(MyStruct)
   var iface1 ISomeInterface1 = s
   var iface2 ISomeInterface2 = s
}
```
Вот это все равно что я в kotlin написал : 
```kotlin
class MyStruct : ISomeInterface1, ISomeInterface2
```

И такая функция форсирует компилятор посмотреть - есть ли нужные реализации. А IDEA сама создает
еще и обертки под методы недостающие.
Но так-то это бредово.


Да и то этот хак не работает если сделать так:
```golang
type MyStruct struct {
    ISomeInterface1
    ISomeInterface2
}
func _MyStructImplements() {
   var s = new(MyStruct)
   var iface1 ISomeInterface1 = s
   var iface2 ISomeInterface2 = s
}
```

Все типа "реализовал" интерфейсы!!!


Короче в этом вопросе GoLang который "чуваки я не ООП, я блин C, но мультипарадигмальный и при этом не С++" предлагает
нечто непотребное ни с точки зрения языка, ни с точки зрения компиляции, ни с точки зрения рантайма, ни с точки зрения
ООП. И не трейт и не интерфейс и не абстрактный класс а типа невнятной спеки какой-то эти интерфейсы.
