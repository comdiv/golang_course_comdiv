[![Go Report Card](https://goreportcard.com/badge/github.com/comdiv/golang_course_comdiv)](https://goreportcard.com/report/github.com/comdiv/golang_course_comdiv)

# golang_course_comdiv

Репозиторий для изучения golang Садыков Фагим

## Работы

### Занятие 003 2021-05-17

Выполнение заданий по [Stepic 1.12](https://stepik.org/lesson/228265?unit=200798)
Плюс чтение материалов

#### Тайминг

1. `(01:00)(01:00)` Выполнение степика с просмотром доп примеров из стековерфлоу
2. `(00:08)(01:08)` Читал статью https://blog.golang.org/slices-intro
3. `(00:27)(01:35)` Читал статью и делал немного заданий из https://blog.golang.org/slices
4. `(00:13)(01:48)` Просмотрел "трики" https://github.com/golang/go/wiki/SliceTricks
5. `(00:12)(02:00)` Читал https://habr.com/ru/post/525940/ и смотрел в https://play.golang.org/
   про ссылки и прямое указание срезов

#### Замечания

1. Есть синтаксис с многоточием для автоматического присвоения размера массиву `x := [...]int{1,2,3}`
2. Есть синтаксис присвоения отдельных элементов `x:=[5]int{2: 3, 3: 17}`
3. (+) Как и все переменные для простых типов массив инициализируется значениями по умолчанию, а не нуллами
4. (+) Можно как в питоне свапнуть значения переменных, включая элементы массивов `x[0],x[1]=x[1],x[0]`
5. (-?) То что срезы то на одном массиве работают (и меняют его) и тут же если переполняются стряпают новый - выглядит
   хотя и оптимизировано по хранению, но источником багов. Я бы предпочел явный какой-то механизм.
6. (!) Надо помнить, что слайсы идут по ссылке, а массивы по значению при передаче в функциий, ПРИЧЕМ на самом деле и
   срезы по значению, но внутри там ссылки на хранилища
7. (?) https://blog.golang.org/slices - всюу до этого структура слайса описывалась как `(*[]T, size, cap)` а тут дается
   иная картинка, с хидером и указателем на первый элемент
8. (-) https://github.com/golang/go/wiki/SliceTricks - необходимость при удалениях еще и явно подчищать остатки если там
   что-то ссылочное
9. (-) https://github.com/golang/go/wiki/SliceTricks - кажется достаточно резонным вопрос, почему эффективные варианты
   операций не сделаны в основной библиотеке golang а должны как тайное знание такими сниппеты передаваться

В целом понятно. Но не очень нравится, что слайс это одновременно и вьюха над готовым массивом и динамический массив
одновременно. Понятно в принципе как устроено, но при чтении кода, особенно если явно не известна длина среза - сложно
понять - будет или нет подмена хранилища под срезом или нет и т.д. Корче в сочетании с необходимостью ставить nil для
ссылочных типах при изменении, мне кажется что срезы - эта такая точка в которой много очень скрытых ошибок формируется.

#### Результаты

По степику все сведено в [директории](./cmd/lesson_003), особенно ничего особенного в заданиях нет.

По второй статье делал некоторые задания, например

1. [типа сложное для указателе и UTF](https://blog.golang.org/slices#TOC_5.)
    - [пример тут](./cmd/lesson_003/lesson_003_art_02_ex1p.go)

### Занятие 002 2021-05-12

#### 002.01 Выполнение 1.4 - 1.11

Плюс контроль времени (итого `04:30` с некоторым погружением )

1. `(+00:03)(00:03)` Читал до https://stepik.org/lesson/230465/step/5?unit=202984
2. `(+00:54)(00:57)` Завис на теме строк, что это хоть и UTF, но набор байтов, а не символов
3. `(+00:15)(01:13)` Дочитал до https://stepik.org/lesson/228261/step/8?unit=200794 и решил разобраться
   со [`fmt.Scan(&a, &b, ...)`](cmd/lesson_002_scan_multiple.go)
4. `(+00.22)(01:35)` Вернулся и прозависал с некорректной частью курса, что дескать тип выражения определяется первым
   операндом, [опровержение](internal/experiments/lesson2_go_operandorder_test.go)\
5. `(+00:35)(02:10)` Доделывал все задания по 1.5, в последнем примере постарался покошернее с константами и контролем
   ввода
6. `(+02:18)(04:30)` Собственно проходил и делал все остальные задания

##### Что надо явно иметь в виду

1. (???) Тип смешанного типа выражений определяется по `типу первого операнда`
   похоже что [ошибка в документации](https://stepik.org/lesson/228261/step/6?unit=200794)

> Арифметические операторы применяются к числовым значениям и дают результат того же типа, что и первый операнд

Но это не так, по факту как и во всех нормальных языках идет приведение к более полному типу,
опровергается [тестом](internal/experiments/lesson2_go_operandorder_test.go),
оставил [камент в курсе](https://stepik.org/lesson/228261/step/6?discussion=3798398&unit=200794)

однако потом опять какой-то геморрой:

```
  for c:=x;c<y;years,c =years+1, int(float32(c) * (1.0 + float32(p) / 100.0)) {
    }
```

пришлось так делать, инече не хотел считать проценты и потом до целого округлять

2. (-) В go ***нет*** `префиксного инкремента ++x`
3. (+) Множественный скан косоли работает и через `arg1 ENTER arg2 ENTER ...`, так и через `arg1 arg2 ... ENTER`
4. (-) `fmt.Print` по разному ведет себя с пробелами в зависимоти от того есть ли
5. (?) В списке констант если не указать ни типа ни значения - возьмется предыдущее, какое-то косвенное присвоение,
   зависящее от порядка строк, не очень понятно (???)
6. (+?) `iota` - понятно что это просто аналог `ordinal` в `enum` у того же Kotlin, но тем не менее странноватый
   оператор, необычный
7. (+) `if` может содержать пред-инструкцию
8. (-?) не очень понятно зачем нужен `fallthrough`
9. (+) есть `switch` со свободными условиями
10. (+?) с одной стороны хорошо, что `default` в `switch` не обязатепен, но так то это точка проникновения сложных
    ошибок
11. (+) все же классический for в котором сразу все можно делать в заголовке это хорошо

##### В Go строки - это просто байты, хотя по умолчанию UTF-8

Подзавис на 45 минут с тем что строки это не символы, а байты пока разбирался с этим делом подосвоил создание и запуск
тестов. [Вот первые тесты про utf-8 lesson2_utf8_string_index_test.go](internal/experiments/lesson2_utf8_string_index_test.go)
, запуск тестов [Makefile](Makefile) `make test_experiments` или если все то `make test`

#### 002.02 Исполнить `hello, go!` без использования IDE

Для облегчения сдачи и контроля выполнения исполнил в виде [Bash скрипта](./scripts/lesson_002_noid.sh)

Внутри происходит инициализация пустой директории, создание файла .go и его выполнение с контролем корректности итогов
выполнения.

Файлы GO гарантировано порождаются во временной директории `./tmp/lesson_002_noid` не зависимо от точки файловой системы
откуда запущен скриптю

Для запуска

1. Если в системе настроен GOPATH, то просто `./scripts/lesson_002_noid.sh`
2. Если нет, то соответственно `GOPATH=<путь до go/bin> ./scripts/lesson_002_noid.sh`

В результате должно быть напечатано следующее:

```
Out from go run
Hello, Go!
Using just created lesson_002_noid(.exe)
Result is: Hello, Go!
All is Ok!
```

### Занятие 001 2021-05-11

[сслка на задание](https://classroom.google.com/u/0/c/MzM5NDA2NTc2ODk5/a/MzM5NDA2NTc2OTY0/details)

#### 001.01 Структура проекта

Создан пустой репозиторий. В репозиторий сразу добавлен

1. [README.md](README.md)
2. [.gitignore](.gitignore)
3. [Makefile](Makefile) - заготовка
4. [go.mod](go.mod) - заготовка

##### 001.02 Первая программа

В соответствии с [заданием](https://stepik.org/lesson/228260/step/1?unit=200793), добавлено
начальное [`Hello, go` приложение](cmd/lesson_001_hellogo.go).

Запуск программы добавлен в [Makefile](Makefile)

1. `make run_lesson_001_hellogo` - запустит только этот пример
2. `make runall` - для запуска в составе всех примеров

#### 001.03  "локальное окружение"

1. Windows 10
2. GoLang 1.16.4
3. GoLand

Файлы для GoLand проверены на отсутствие каких-то локальных ссылок и прочих непереносимых сведений и включены в проект.
